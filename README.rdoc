= PerfectQueue

Highly available distributed queue.

It provides exactly-once semantics unless backend database fails. Pushed tasks are surely retried by another worker client even if a worker fails. And it never delivers removed/canceled tasks.

Backend database is pluggable. You can use any databases that supports CAS (compare-and-swap) operation. PerfectQueue supports RDBMS and Amazon SimpleDB for now.


== Architecture

PerfectQueue uses following database schema:

  (
    id:string    -- unique identifier of the task
    data:blob    -- additional attributes of the task
    timeout:int
  )

1. list: lists tasks whose timeout column is old enough.
2. lock: updates timeout column of the first task
3. run: executes a command or runs a script
   * if the task takes long time, updates the timeout column. this is repeated until the process is finished.
   * if the task takes more long time, kills the process.
4. remove: if it succeeded, removes the row from the backend database.
5. or leave: if it failed, leave the row and expect to be retried.


== Usage

=== Submitting a task

_Using command line:_

  # RDBMS
  $ perfectqueue --database mysql://user:password@localhost/mydb --table perfectqueue --push unique-key-id='{"any":"data"}'

  # SimpleDB
  $ perfectqueue --database mysql://user:password@localhost/mydb --table perfectqueue --push unique-key-id='{"any":"data"}'

_Using PerfectQueue library:_

  require 'perfectqueue'
  
  # RDBMS
  require 'perfectqueue/backend/rdb'
  db = PerfectQueue::Backend::RDBBackend.new('mysql://user:password@localhost/mydb', table='perfectqueue')

  # SimpleDB
  require 'perfectqueue/backend/simpledb'
  db = PerfectQueue::Backend::RDBBackend.new('AWS_KEY_ID', 'AWS_SECRET_KEY', 'your-simpledb-domain-name')
  
  db.submit('unique-key-id', '{"any":"data"}')


Alternatively, you can insert a row into the backend database directly.

_RDBMS:_

  > CREATE TABLE IF NOT EXISTS perfectqueue (
        id VARCHAR(256) NOT NULL,
        timeout INT NOT NULL,
        data BLOB NOT NULL,
        created_at INT NOT NULL,
        PRIMARY KEY (id)
      );
  > SET @now = UNIX_TIMESTAMP();
  > INSERT INTO perfectqueue (id, timeout, data, created_at) VALUES ('unique-task-id', @now, '{"any":"data"}', @now);

_SimpleDB:_

  require 'aws'  # gem install aws-sdk
  db = AWS::SimpleDB.new
  domain = db.domains['your-simpledb-domain-name']
  
  now = "%08x" % Time.now.to_i
  domain.items['unique-task-id'].attributes.replace(
      'timeout'=>now, 'data'=>'{"any":"data"}', 'created_at'=>now,
      :unless=>'timeout')


=== Canceling a queued task

_Using command line:_

  $ perfectqueue ... --cancel unique-key-id

_Using PerfectQueue library:_

  db.cancel('unique-key-id')


Alternatively, you can delete a row from the backend database directly.

_RDBMS:_

  > DELETE FROM perfectqueue WHERE id='unique-key-id';

_SimpleDB:_

  domain.items['unique-task-id'].delete


=== Running worker client

Use _perfectqueue_ command to execute a command.

  Usage: perfectqueue [options] [-- <ARGV-for-exec-or-run>]
          --push ID=DATA               Push a task to the queue
          --show                       Show queued tasks
          --cancel ID                  Cancel a queued task
          --configure PATH.yaml        Write configuration file
          --exec COMMAND               Execute command
          --run SCRIPT.rb              Run method named 'run' defined in the script
      -t, --timeout SEC                Time for another worker to take over a task when this worker goes down (default: 30)
      -b  --heartbeat-interval SEC     Threshold time to extend the timeout (heartbeat interval) (default: timeout * 3/4)
      -x, --kill-timeout SEC           Threshold time to kill a task process (default: timeout * 10)
      -X, --kill-interval SEC          Threshold time to retry killing a task process (default: 60)
      -i, --poll-interval SEC          Polling interval (default: 1)
      -r, --retry-wait SEC             Time to retry a task when it is failed (default: same as timeout)
      -e, --expire SEC                 Threshold time to expire a task (default: 345600 (4days))
      -w, --worker NUM                 Number of worker threads (default: 1)
      -d, --daemon PIDFILE             Daemonize (default: foreground)
      -f, --file PATH.yaml             Read configuration file
          --database URI               Use RDBMS for the backend database (e.g.: mysql://user:password@localhost/mydb)
          --table NAME                 backend: name of the table (default: perfectqueue)
          --simpledb DOMAIN            Use Amazon SimpleDB for the backend database (e.g.: --simpledb mydomain -k KEY_ID -s SEC_KEY)
      -k, --key-id ID                  AWS Access Key ID
      -s, --secret-key KEY             AWS Secret Access Key
      -o, --log PATH                   log file path
      -v, --verbose                    verbose mode


==== --exec

Execute a command when a task is received. The the data column is passed to the stdin and the id column passed to the last argument. The command have to exit with status code 0 when it succeeded.

_Example:_

  #!/usr/bin/env ruby
  
  require 'json'
  js = JSON.load(STDIN.read)
  puts "received: id=#{ARGV.last} #{js.inspect}"
  
  # $ perfectqueue --database sqlite://test.db --exec ./this_file -- my cmd args

When the kill timeout (-x, --kill-timeout) is elapsed, SIGTERM signal will be sent to the child process. The signal will be repeated every few seconds (-X, --kill-interval).


==== --run

This is same as 'exec' except that it creates a instance of a class named 'Run' defined in the file. The class should has 'initialize(task)', 'run' and 'kill' methods. You can get data column and id column of the task from the argument of the initialize method. It is assumed it succeeded if the method doesn't any raise errors.

_Example:_

  require 'json'
  
  class Run
    def initialize(task)
      @task = task
    end
  
    def run
      js = JSON.load(@task.data)
      puts "received: id=#{@task.id} #{js.inspect}"
    end
  
    def kill
      puts "kill!"
    end
  end
  
  # $ perfectqueue --database sqlite://test.db --run ./this_file.rb -- my cmd args

When the kill timeout (-x, --klill-timeout) is elapsed, Run#kill method will be called (if it is defined). It will be repeated every few seconds (-X, --kill-retry).


==== --configure

Write configuration file and exit. Written configuration file can be used with -f option:

_Example:_

  ## create myqueue.yaml file
  $ perfectqueue --configure myqueue.yaml --database mysql://root:my@localhost/mydb --run myrun.rb -- my cmd args

  ## run perfectqueue using the configuration file
  $ perfectqueue -f myqueue.yaml


==== --show

Show queued tasks.

_Example:_

  $ perfectqueue --database sqlite://test.db --show
                          id                 created_at                    timeout  data
                       task1  2011-08-23 23:07:45 +0900  2011-08-23 23:07:45 +0900  {"attr1":"val1","attr":"val2"}
  1 entries.


